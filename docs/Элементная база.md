# Выбор технологии
Элементная база для умных устройств во многом определяется способом их связи друг с другом и с контроллером. Это может быть провод или радиосвязь.
По проводу можно передавать не только данные, но и питание. Это позволяет избежать головной боли с заменой батареек и аккумуляторов. 

Однако, чтобы проложить провод до каждого датчика, нужен готовый проект на момент черновой отделки и очень много провода.
Радиосвязь вне конкуренции, поскольку не требует проведения ремонтных работ и не привязывает расположение датчиков к конкретным местам в квартире.
Слабым местом является ограниченная дальность действия, однако, в условиях наших квартир этим недостатком можно пренебречь.
Поскольку радиосвязь - это удобно и просто, мы взяли эту технологию коммуникации за основу для наших датчиков.

Есть множество вариантов организации связи между модулями, но среди открытых и наиболее распространенных в решениях умного дома считаются следующие:
ZigBee, Z-Wave, WiFi, Bluetooth

При выборе стандарта радиосвязи мы руководствовались доступностью устройств, широтой распространения технологии и простотой настройки. 
Наилучшим образом под эти критерии подходят WiFi и Bluetooth. Например, в Raspberry 3 Pi и Orange Pi 2 Plus эти стандарты поддерживаются из коробки.

Bluetooth LE (BLE) специальная редакция стандарта для энергоэффективного обмена небольшими объемами данных. В этом плане BLE значительно выигрывает у WiFi. К тому же WiFi требует более сложной настройки - указания имени и ключа сети, которые могут меняться.
Bluetooth к Интернет не подключен, это независимый контур, его защиту можно оставить на последний момент.

# Выбор элементной базы
Наверно самым распространенным чипом, в который встроена возможность связи по Bluetooth LE, является семейство чипов фирмы [Texas Instruments CC2540/2541](http://www.ti.com/lit/ug/swru271g/swru271g.pdf).
Модули с этим чипом стоят очень дешево и доступны практически в любом магазине электронных компонентов.
Обычно на модуле размещены необходимые согласующие элементы, вспомогательные светодиоды и контакты для подключения.

Чип CC2541 относится к катеории SoC (System on Chip), то есть представляет собой полноценный микроконтроллер, с приличным объемом памяти, встроенным АЦП, таймерами и модулем связи Bluetooth LE.
По идее, этот чип идеально подходит для реализации компонентов умного дома - может считывать показания датчиков, управлять реле и т.п.
Однако, с этим есть некоторые сложности. Легкости, присущей программированию Atmel-контроллеров в среде Arduino, здесь нет. 
Программирование CC2541 может выполнить только подготовленный специалист.

Но есть и хорошая новость. Во всех разновидностях модулей, построенных на базе CC2541, уже есть готовая прошивка, которая может что-то делать.
Вопрос лишь в том, что именно. Здесь мы уже покопались и делимся с вами результатами исследования.

# Обзор BLE-модулей
Прежде чем покупать модуль, четко определитесь с тем, какие возможности вам от него потребуются. 
Модули разных производителей содержат разные прошивки, их нужно уметь отличать.

| Название модуля|Производитель|Прошивка|Скорость, бод|Описание|
| :----------- | :----------: | :----------: | :----------: | :----------: |
|[HM-10 BLE 4.0](http://fab.cba.mit.edu/classes/863.15/doc/tutorials/programming/bluetooth/bluetooth40_en.pdf)|JNHuaMao|||Самый полнофункциональный BLE-модуль. Нужно уметь визуально отличать его от других реализаций, чтобы не купить аналог|
|[CC41-A](http://img.banggood.com/file/products/20150104013145BLE-CC41-A%20Spefication.pdf) [описание команд](http://4ipov.net/bluetooth_4.0_BLE_module_CC2541_CC41-A)|Bolutek|V3.0.6|9600|Самый простой BLE-модуль. Может только передавать данные на хост-устройство. |
|[JDY-08](https://fccid.io/2AM2YJDY-08/User-Manual/User-Manual-3511895.pdf) [описание команд](https://github.com/kichMan/JDY-08)||V3.383|115200|Содержит развитые возможности по управлению выходами IO и PWM|

# Начало работы
Спецификация [Bluetooth LE](https://www.bluetooth.com/specifications/gatt) определяет некий способ работы с BLE-устройствами:

1. сначала устройства нужно подключить по радиоканалу;
2. при помощи утилит (или ПО, установенного на телефоне) можно запросить перечень характеристик (или функций), поддерживаемых устройством;
3. тем же способом можно считывать/записывать значения характеристик.
То, на какие характеристики будет какой отклик, определяется прошивкой BLE-модуля.

Подайте питание на BLE-модуль и светодиод, расположенный на платке, скорее всего начнет периодически мигать.
Это означает, что соединение с модулем не установлено.

Подключаемся к RPi по SSH и выполняем такие команды:
```
sudo -s
docker exec -it hass bash
```

Теперь мы можем выполнять команды внутри docker-контейнера с Home Assistant. Запустим сканирование BLE-устройств:
```
# hcitool lescan
LE Scan ...
00:15:84:00:70:C1 CC41-A
```

Пробуем подключиться, после чего светодиод на платке станет светиться постоянно:
```
# hcitool lecc 00:15:84:00:70:C1
Connection handle 64
```


# Настройка модулей
Взаимодействие с CC2541 осуществляется через интерфейс UART. На платке специально выведены ножки Rx и Tx для подключения к ПК или микроконтроллерам.
Предварительно необходимо настроить модуль, например, задать ему дружественное имя, выбрать режим работы, мощность радиосигнала и т.п.
Достигается это передачей AT-команд через UART-интерфейс, прямо как в старых модемах.
У каждой прошивки есть свой собственный набор AT-команд и спецификация, где описано их назначение.

Есть два простых способа настройки BLЕ-модуля:

1. при помощи кабеля конвертера USB - RS232 и программки типа Terminal
2. при помощи Arduino-платы, к пинам которой подключается BLE-модуль.

Для реализации второго сценария мы подготовили схему подключения:

![Схема USB-RS232](https://github.com/cutecare/cutecare-docs/blob/master/images/TTL_bb.png?raw=true)


Откройте COM-монитор, встроенный в Arduino IDE, и загрузите следующую программу в Arduino. В результате BLE-модуль СС41-A сообщит свой адрес и версию прошивки.
```
#include <SoftwareSerial.h>

SoftwareSerial bleSerial(2, 3); // RX, TX

void setup() {
  // проверьте, что скорость связи совпадает со скоростью по умолчанию для конкретного BLE-модуля
  bleSerial.begin(9600);
  bleSerial.setTimeout(500);
  Serial.begin(9600);
  configureDevice();
}

void loop() {
  char c;
  if (Serial.available()) {
    c = Serial.read();
    bleSerial.print(c);
  }
  if (bleSerial.available()) {
    c = bleSerial.read();
    Serial.print(c);    
  }
}

void configureDevice() {
  sendCommand("AT");
  sendCommand("AT+VERSION");
  sendCommand("AT+VER");
  sendCommand("AT+LADDR"); 
}

void sendCommand(const char * data) {
  Serial.println(data);
  bleSerial.println(data);
  while(bleSerial.available()) {
    Serial.println(bleSerial.readStringUntil('\n'));
  }
  delay(20);
}
```

Теперь вы во всеоружии для того, чтобы перейти к сборке умных датчиков и исполняющий устройств. 
Вперед!
